Java语言基础
===================================================================================
1. Linux简介
2. Java简介
3. Java APP
4. Java的注释
5. Eclipse
6. Java变量
7. 进制转换基础
8. Java数据类型
9. 数据类型转换
10. Java Method
11. Java运算符
12. 分支流程控制
13. 循环控制
14. Java Array
15. 数组的复制与动态扩展算法
16. 数组的排序
17. 方法的递归调用
===================================================================================
1. Linux简介
  1) 文件系统
  2) 当前工作目录: 当前正在使用的默认文件夹(文件夹=目录)
    $ pwd #打印(显示)当前工作目录
  3) 用户主目录(user home): 属于当前登录用户个人的目录, 用户拥有对自己用户主目录全部管理权限
  4) 创建文件夹
    $ mkdir demo #在当前文件夹(工作目录)里创建文件夹demo
  5) 切换(更改)当前工作目录
    $ cd .. #切换到上层目录
    $ cd / #到跟目录
    $ cd #命令默认返回用户主目录(user home)
  6) 显示文件夹内容
    $ ls
    $ ls -al
  7) 绝对路径和相对路径
    a. 以跟(root)"/"为开始的路径是绝对路径
    b. 不是以"/"开始的是相对路径, 相对路径默认相对于当前目录
  8) 删除文件/目录
    $ rm file #删除文件
    $ rm -rf demo #删除文件夹
  9) 启动eclipse 
    $ cd /opt/eclipse
    $ ./eclipse


2. Java简介
  1) Java特点: 简单, 面向对象, 跨平台, 安全, 多线程支持
  2) Java的跨平台: 通过JVM实现了跨平台技术
    Java源代码(*.java): 经过Java的编译器编译成
    Java字节码(*.class): 执行文件
      a. Java字节码经过JVM的解释为具体平台的具体指令, 并执行
      b. 不同平台有不同的JVM, 主流平台都提供了JVM. 所以Java字节码可以在所有平台上能够解释执行. 在这个意义上Java是跨平台的. 也就是说, Java的字节码是跨平台的
  3) Java JDK 
    JDK: Java开发工具包/opt/jdk
      |-- bin: 开发工具(命令: java, javac, jar, javad, jar, rmic, jps, ...)
      |-- lib: 开发工具的核心实现(tools.jar)
      |-- src.zip: API的源文件System.java
      |-- jre: Java运行环境
        |-- lib: Java API(应用编程接口System.class, 系统类库String.class, ...)
        |  |-- rt.jar: Java提供的现成组件
        |-- bin: JVM(Java虚拟机)


3. Java APP
  1) HelloWorld.java, JFrameHelloWorld.java
  2) Java的编译
    project
      |--src
      |  |--core
      |  |  |-- HelloWorld.java
      |  |  |-- JFrameHelloWorld.java
      |--bin
      |  |--core
      |  |  |-- HelloWorld.class
      |  |  |-- JFrameHelloWorld.class


4. Java的注释, 被Javac(编译器)忽略的部分
  1) 单行注释 // ...
  2) 多行注释 /* */
  3) 文档注释 /** */


5. Eclipse
  1) 来自IBM开源, 有eclipse.org基金会维护开发, 是主流的Java开发平台, 可以开发PHP, Ruby, Android, SUN对这个软件很有意见
  2) eclispe是Java开发的, 需要JDK来运行


6. Java变量
  1) 变量就是自然语言中的代词
    Person he;
    int age = 15; 
    // age = 00000000 00000000 00000000 00001111;
    System.out.println(age);// 15
  2) Java中的变量, Java是强类型语言
    a. 变量必须声明, 并且初始化以后使用
    b. 变量必须有明确的类型
    c. 变量不能重复定义
  3) 变量的作用域
    a. 在声明的地方开始, 到块结束为止
    b. 离开变量的作用域结束, 变量将回收


7. 进制转换基础
  1) 十进制 
    a. 数字: 0 1 2 3 4 5 6 7 8 9
    b. 逢10进1
    c. 基数: 10
    d. 权(基数的次幂数): 10^n
      23678(10) = 2*10000 + 3*1000 + 6*100 + 7*10 + 8*1 
                = 2*10^4 + 3*10^3 + 6*10^2 + 7*10^1 + 8*10^0 
                = 23678
  2) 二进制
    a. 数字: 0 1
    b. 逢2进1
    c. 基数: 2
    d. 权(基数的次幂数): 2^n
      01000001(2) = 1*64 + 1*1
                  = 65(10)
    10进制   2进制
     0      0
     1      1
     2     10
     3     11 
     4    100
     5    101
     6    110
     7    111
     8   1000
     9   1001
    10   1010
    11   1011  = 8 + 2 + 1 = 11
    12   1100
    13   1101
    14   1110
    15   1111
    ...
                  128 64 32 16 8 4 2 1
    11001100(2) =  1   1  0  0 1 1 0 0(2)
                = 128 + 64 + 8 + 4 
                = 204(10)
  3) 补码(计算机不方便表达负数, 利用高位为1是数字作为负数)
    a. 补码规定, 以4位补码为例:
      高位为1的数作为负数(规定出来负数: -8 ~ -1), 高位被称为符号位
      超过4位的运算, 高位舍弃(溢出现象), 运算封闭
    b. 补码规律
      1. 补码运算大多满足数学规则
        补码有缺点: 如: max + 1 = min 不满足数学运算规则
        编程实践中要避免缺点, 利用优点(了解补码的意义)
      2. 补码是有范围的: 4 位补码只能表示 -8 ~ 7
      3. 存在规律(补码规律, 不是数学规律): ~n + 1 = -n  
        利用这个规律, 可以计算负数的补码: +5 的补码取反再加1就是 -5 的补码了
      4. 常见的考题:
        System.out.println(~-3);// 2
        System.out.println(~-3+1-1);// 3-1
        System.out.println(~3);
      5. 二进制乘法
              -2  1110
           *  -2  1110
        ---------------- 
                  0000
                 1110   
                1110   
               1110    
        +        1       
        -----------------
         4        0100
      6. 其它
         8 位补码: -128~127 
        16 位补码: -32768(-2^15) ~ 32767(2^15-1)

        10进制  4位补码  8位补码    32位补码
        min         -------   10000000 00000000 00000000 00000000
        ...
        -129        --------  11111111 11111111 11111111 01111111 
        -128        10000000  11111111 11111111 11111111 10000000
        -127        10000001  11111111 11111111 11111111 10000001
        ...
        -11   ----  11110101  11111111 11111111 11111111 11110101
        -10   ----  11110110
         -9   ----  11110111  
         -8   1000  11111000
         -7   1001  11111001
         -6   1010  11111010
         -5   1011  11111011
         -4   1100  11111100
         -3   1101  11111101  11111111 11111111 11111111 11111101
         -2   1110  11111110  11111111 11111111 11111111 11111110
         -1   1111  11111111  11111111 11111111 11111111 11111111 
          0   0000  00000000  00000000 00000000 00000000 00000000 
          1   0001  00000001  00000000 00000000 00000000 00000001
          2   0010  00000010  00000000 00000000 00000000 00000010
          3   0011  00000011  00000000 00000000 00000000 00000011
          4   0100  00000100  00000000 00000000 00000000 00000100
          5   0101  00000101  00000000 00000000 00000000 00000101
          6   0110  00000110
          7   0111  00000111
          8   ----  00001000
          9   ----  00001001 
         10   ----  00001010  00000000 00000000 00000000 00001010
        ...
        126   ----  01111110  00000000 00000000 00000000 01111110 
        127   ----  01111111  00000000 00000000 00000000 01111111
        128   ----  --------  00000000 00000000 00000000 10000000
        ...
        max   ----  --------  01111111 11111111 11111111 11111111

  4) 16进制, 是2进制的简写, 方便专业人员书写2进制数据
    a. 数字: 0 1 2 3 4 5 6 7 8 9 a b c d e f
    b. 逢16进1
    c. 基数: 16
    d. 权(基数的次幂数): 16^n
      41(16) = 4*16 + 1*1
           = 65(10)
           = 0100 0001(2)
             8421 8421
           4    1   (16)

   
8. Java数据类型: 分为引用类型和基本数据类型
  1) 基本数据类型: 8种
    byte, short, int, long
    float, double 
    char
    boolean
  2) 整数类型byte, short, int, long, 都是有符号(补码)整数
    byte   8位 0x7f(127) ~ 0x80(-128)
    short 16位 0x7fff(32767) ~ 0x8000(-32768)
    int   32位 0x7fffffff(2G-1, 2^31-1, 21亿) ~ 0x80000000(-2G)
    long  64位
    a. 整数字面量(直接量)默认是 int 类型, 如果整数字面量不超出小类型(byte)范围, 可以给小类型变量直接赋值
    b. java 底层 byte, short 按照32位计算
    c. long 类型的字面量使用 "L", "l" 后缀
  3) 浮点数, 小数 (不必掌握浮点数的存储方式) 
    a. IEEE Float:
      浮点数原理: 10进制浮点数(科学计数法)原理
        2356189. = 2.356189 * 10^6
      概念:
        尾数: 2.356189 
        指数: 6
        基数: 10 常数
        pi = 3.14(3.1415926535897932384626433)
    b. 二进制浮点数:
      101001010101. = 10100101010.1 * 2
              = 1010010101.01 * 2^10
              = 101001010.101 * 2^11
              = 1.01001010101 * 2^1011
       概念:
         尾数: 1.01001010101
        指数: 1011
        基数: 2
    c. float: 32位(1位符号位, 8位指数, 23位尾数)
       精度: 23 位
        int max = 01111111 11111111 11111111 11111111
        float f = 1.1111111 11111111 11111111 * 2^00011110
    d. double: 64位(1位符号位, 11位指数, 52位尾数)
      double: 双倍精度的浮点数
    e. 浮点数的字面量: 默认是 double, D/d 后缀是double, f/F 是float
  4) 字符类型 char, 字符是一个16位无符号整数, 是一个二进制数, 数值是一个字符的unicode编码值 
    unicode 编码: 是全球范围内的编码方法, 编制了英文, 中, 日, 韩, 阿拉伯, 希伯来等8万 + 字符, 其中英文部分与 ASCII 兼容, 英文字符和数字是连续编码的.
      ASCII: 0~128
      Java char: 0~65535, 不能表示全部 unicode 但是可以表示最常用的部分
        最小值:0, 最大值:65535 = 2^16-1
        字符字面量使用单引号为定界符号'中', 字面量也是整数常量
        特殊字符采用转义字符表示: '\n', '\t', '\\', '\b', '\r', '\'', '\"', '\u4e2d' 
          char c = '\\';
          'X' - 'A' = N
          'x' - 'a' = N
          X  = 'c' - 'a' + 'A'
  5) boolean 布尔类型 表达: 真(true)/假(false)
     建议使用长变量名定义变量
      boolean started = true;
      boolean isMan = true;
      isMan = false;
      boolean used = true;//二手的
      if(used){
        System.out.println("打八折"); 
      }
    不建议 定义没有意义的变量
      boolean u = true;//u = you
      boolean flag = false;
      if(flag){
        System.out.println("打八折"); 
      }  


9. 数据类型转换 
  char -> byte -> short -> int -> long -> float -> double
  1) 自动类型转换, 正方向, 小类型到大类型的转换会自动完成, 符号位会自动扩展, 负数补1, 正数补0, 保证补码数值不变
    整数到浮点数转换会损失精确度
    自动类型转换也叫"隐式类型转换", 是自动发生的, 一般不需要处理
      int i = -1;
      long l = i;
  2) 强制类型转换(显示类型转换), 需求明确处理, 是按照反方向进行的转换, 这种转换会溢出, 或者损失精度.
    要注意数据的范围
      int i = 128+256;// 00000000 00000000 00000001 10000000 
      byte b = (byte)i;//-128
      long l = 0xf80000000L;
      int c = (int)l;//负数
      
      l = 8;
      int d = (int)l;
      
      float pi = (float)3.1415926535;//损失精度

      char c = '0';
      char x = (char)(c+2);


10. Java Method
  1) 方法就是函数: y = f(x) = 3x + 6;
  2) 方法的语法
    修饰词  返回值类型  方法名  参数列表 {
      // 方法体
    }
    如:
      public static void main(String[] args){}
      
      public static int f(int x){
        int y = 3 * x + 4;
        return y;
      }
  3) 如果有返回值定义就必须有 return 语句, 返回和返回值类型兼容的数据
  4) 方法的参数和方法内部的变量都是局部变量, 这些变量作用域只在方法内部
  5) 实参: 方法调用时候实际传递的参数变量
          形参: 方法的参数定义, 是临时变量


11. Java运算符
  1) 数学运算符  + - * / %
    a. 运算的封闭性(补码运算的封闭性): 
      1. 同种类型参与运算(可能需要自动类型转换)
      2. 返回同种类型(可能发生:上溢出和下溢出)
      3. byte, short, char 按照 int 运算
        如: int a = 1 + 'A';
    b. 整数的除法是整除, 除以2相当于移位运算(移动小数点) 
    c. Java 中字面量的运算被 Javac 优化了, 优化为一个固定的常量
    d. % 计算除法的余数
      1. 0对其他数的余数是0
      2. n%3是周期函数, 函数值 [0,3)
      3. 负数的余数是负数(考试可能出现, 工作中很少用)
  2) 自增(自减)运算 ++ --
    a. 可以将当前变量自我增加(减少)1
    b. i++, 后++, 先将 i 的值作为整个表达的值, 然后将 i 增加1
    c. ++i, 先++, 先将 i 增加1, 然后将 i 的值作为整个表达的值
  3) 逻辑与比较运算 
    a.逻辑运算 与(并且)&&  或(或者)||  非(否则)!  
      非短路的逻辑运算  &  | , 比较少使用, 逻辑不合理
    b. 比较运算, 比较变量的值, 就是逐个"位"比较值: > >= < <= == !=
      基本类型变量的值就是基本值如: i=1
      引用类型变量的值是对象地址值(在面向对象阶段详细讲解)
        int i = 1;
        long l = 1;
        System.out.println(i==l); //true
  4) 条件运算符(3元运算符) 
    语法: 布尔表达式 ? 表达式1 : 表达式2
      当"布尔表达式"为 true 时候, 表达式1作为整个表达式的值, 否则 表达式2作为整个表达式的值
        如: 
          boolean isBoy = true;
          int level = isBoy ? 2 : 3 ;// 2


12. 分支流程控制
  1) if ... else
    if(布尔表达式1) {
      // 语句块1
    } else if(布尔表达式2) {
      // 语句块2
    } else if(布尔表达式3) {
      // 语句块3
    }else {
      // 语句块4
    }
  2) switch ... case
    switch(整数表达式) { 
      case 整数常量1:
        // 语句序列
        break;
      case 整数常量2:
        // 语句序列
        break;
      default: 
        // 语句序列
    }
    a. switch条件: 只能是整数(int, byte, char, short)表达式, switch不能处理long或其他类型
    b. case只能是整数(int, byte, char, short)常量, 不能使用变量及表达式. 如: '中'
    c. break跳转到switch结束继续执行, 可以根据业务逻辑是否使用经常都写break


13. 循环控制
  1) while
    while(布尔表达式) {
      // 循环体
    }
  2) for
    for(初始化表达式(1);布尔表达式(2); 递增表达式(4)) {
      // 循环体(3)
    }
  3) do ... while
    do {
      // 循环体
   } while(布尔表达式);


14. Java Array
  1) 数组变量的声明
    int[] ary; //声明了数组变量ary, 数组变量是代词
    int ary[]; //为了与C语法兼容的写法, 不建议写法
  2) 数组对象动态初始化
    ary = new int[4]; //数组变量引用了具体数组对象, 就是代词, 指代了具体事务
                      //数组元素是自动初始化的, 自动初始化为"零"值
                      //"零"值: 0, 0.0, \u0000, false, null
    ary = new int[]{1,2,3}; //直接给出元素的初始化
  3) 数组对象的静态初始化, 只能用在声明数组变量时候同时初始化, 不能用于赋值语句
    int[] ary = {1, 2, 3};
    ary = {3,4,5,6}; //编译错误
  * Java关键字: if, public, class, else, while
  * 特殊关键字: goto, const
  * true, false, null不是关键字, 是字面量
  4) 数组变量, 数组对象, 数组元素 
    int[] ary = {1,2,3};
    ary: 数组变量, 指代一个具体的数组, 同一个变量指代不同的数组
    {1,2,3}: 数组对象
    1/2/3: 数组元素  
  5) 数组元素的访问, 数组对象的大小是固定的, 长度n, 下标0~n-1 
    a. 使用[下标]访问数组元素
    b. 越界访问(小于0/大于等于n), 都会发生运行异常
    c. 使用length属性可以获取数组对象长度
  
15. 数组的复制与动态扩展算法
  1) 数组对象的复制
  2) 数组的扩展问题
    a. Java数组对象的大小是固定的, 数组对象是不能扩展的
    b. 利用数组复制到方法可以变通的实现数组扩展
    c. System.arraycopy()可以复制数组
    d. Arrays.copyOf()可以简便的创建数组副本
    e. 创建数组副本的同时将数组长度增加就变通的实现了数组的扩展


16. 数组的排序
  1) 选择排序
    原理:
      a. 将数组中的每个元素, 与第一个元素比较, 如果这个元素小于第一个元素, 就将这两个元素交换
      b. 每轮使用a的规则, 可以选择出一个最小元素放到第一个位置
      c. 经过n-1轮比较完成排序
      * 每轮选择最小的放到前面
    原理说明:
      {8, 2, 3, 7, 1} 
      {1| 8, 3, 7, 2}
      {1, 2| 8, 7, 3}
      {1, 2, 3| 8, 7}
      {1, 2, 3, 7| 8}
    代码分析: i代表第一个数据的位置, j代码后部每一个数据的位置
          ary     i j ary[i] ary[j] ary[i]>ary[j] [i]<->[j]
      {8|2,3,7,1} 0 1   8      2        true        8<->2
      {2|8,3,7,1} 0 2   2      3        false
      {2|8,3,7,1} 0 3   2      7        false
      {2|8,3,7,1} 0 4   2      1        true        2<->1
      {1,8|3,7,2} 1 2   8      3        true        8<->3
      {1,3|8,7,2} 1 3   3      7        false
      {1,3|8,7,2} 1 4   3      2        true        3<->2
      {1,2,8|7,3} 2 3   8      7        true        8<->7
      {1,2,7|8,3} 2 4   7      3        true        7<->3
      {1,2,3,8|7} 3 4   8      7        true        8<->7
      {1,2,3,7,8} 4
    代码:
      i = 0 ~ < ary.length - 1
      j = i+1 ~ <ary.length
      if(ary[i] > ary[j]) {
        ary[i]<->ary[j]
      }
  2) 冒泡排序
    原理: 
      a. 逐一比较数组中相邻的两个元素, 如果后面的数字小于前面的数字, 就交换先后元素
      b. 经过一个轮次的比较, 一定有一个最大的排在最后的位置
      c. 每次比较剩下的元素, 经过n-1次比较, 可以实现排序
      * 比较相邻元素, 大的向后交换
    原理说明:
      {8, 2, 3, 7, 1}
      {2, 8, 3, 7, 1}
      {2, 3, 8, 7, 1}
      {2, 3, 7, 8, 1}
      {2, 3, 7, 1| 8}
      {2, 3, 7, 1| 8}
      {2, 3, 7, 1| 8}
      {2, 3, 1| 7, 8}
      {2, 3, 1| 7, 8}
      {2, 1| 3, 7, 8}
      {1, 2, 3, 7, 8}
    代码分析: i代表次数, j代表比较位置
          ary     i j j+1 ary[j] ary[j+1] [j]>[j+1] [j]<->[j+1]
      {8,2,3,7,1} 0 0  1    8       2       true      8<->2
      {2,8,3,7,1} 0 1  2    8       3       true      8<->3
      {2,3,8,7,1} 0 2  3    8       7       true      8<->7
      {2,3,7,8,1} 0 3  4    8       1       true      8<->1
      {2,3,7,1|8} 1 0  1    2       3       false
      {2,3,7,1|8} 1 1  2    3       7       false
      {2,3,7,1|8} 1 2  3    7       1       true      7<->1
      {2,3,1|7,8} 2 0  1    2       3       false
      {2,3,1|7,8} 2 1  2    3       1       true      3<->1
      {2,1|3,7,8} 3 0  1    2       1       true      2<->1
      {1,2,3,7,8}
    代码:
      i = 0 ~ < ary.length-1
      j = 0 ~ < ary.length - i -1;  
      if([j]>[j+1]) {
        [j]<->[j+1]
      }
  3) 插入排序
    原理: 
      a. 将数组分为两部分, 将后部分的第一张逐一与前部分每一张比较, 如果当前元素小, 就一点被比较元素
      b. 找到合理位置插入
    原理说明:
      temp = 1
      {8| 2, 3, 7, 1}
      {2, 8| 8, 7, 1}
      {2, 3, 8| 7, 1}
      {2, 3, 8| 8, 1}
      {2, 3, 7, 8| 8}
      {2, 3, 7, 7| 8}
      {2, 3, 3, 7| 8}
      {2, 2, 3, 7| 8}
      {1, 2, 3, 7| 8}
   代码分析: temp代表取出的待插入元素, i代表后组待插入元素位置, j代表前组每个元素的位置
          ary     i  t  j  ary[j]  t<[j] [j]->[j+1] t->[j+1]
      {8|2,3,7,5} 1  2  0    8     true   8->[j+1]   
      {8|8,3,7,5} 1  2 -1                            2->[j+1]
      {2,8|3,7,5} 2  3  1    8     true   8->[j+1]
      {2,8|8,7,5} 2  3  0    2     false             3->[j+1]
      {2,3,8|7,5} 3  7  2    8     true   8->[j+1]
      {2,3,8|8,5} 3  7  1    3     false             7->[j+1]
      {2,3,7,8|5} 4  5  3    8     true   8->[j+1] 
      {2,3,7,8|8} 4  5  2    7     true   7->[j+1] 
      {2,3,7,7|8} 4  5  1    3     false             5->[j+1]
      {2,3,5,7|8} 5
   代码:
     i = 1 ~ <ary.length, i++
     t = [i];
     j= i-1 ~ >=0, j--
     if(t<[j]){
       [j]->[j+1] //移动
     } else {
        break j;
     }
     t->[j+1]//插入
  4) Java系统排序Arrays.sort(), 排序算法性能很好


17. 方法的递归调用
  1) Java的栈: 是Java进程启动时候在内存中开辟的存储空间
    a. 栈内存的利用方式LIFO(后进先出)
    b. Java所有局部变量都在栈中分配(压入), 方法的参数也是局部变量, 局部变量在离开作用域时候回收 就是从栈中弹出(删除) 
  2) Java方法调用使用栈实现, 递归调用就是栈实现的
  3) 递归时候要按照递归深度分配全部临时变量, 栈开销很大, 性能不好, 要注意不要超过栈的大小, 并且一定要给出结束条件, 否则会造成栈溢出错误