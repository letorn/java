java中的线程创建
	Thread类
	线程类Thread包含一个可执行的过程(线程体):run()方法
	
	创建一个线程的为步骤:
	1:继承Thread类
	2:重写run()方法,实现线程体
	3:创建这个线程的实例
	4:调用这个线程实例的[star()]方法,启动线程
	
线程的状态
	线程的5个状态
		NEW  新建的线程
			 当使用new关键字创建一个线程后,该线程就处于新建状态,此时线程还未启动
			 
   RUNNABLE  可运行状态(就绪状态)
   		     当线程处于runnable状态时,那么此线程可随时获得CPU时间片段来执行任务
   		     
    RUNNING  正在运行状态
             此时该线程已经获取CPU时间片段并被CPU执行(调用其run()方法).
             若有一个CPU,那么同一时间就只有一个线程处于running状态,若有两个CPU,
              那么同一时间就有两个线程处于running状态,以此类推.多核CPU有同样效果
             调用yield()方法,可以主动放弃当前时间CPU时间,回到runnable状态,等待下次CPU时间
              
      Block  阻塞状态
             当线程有以下情况会发生阻塞:
             	线程调用了sleep()方法主动放弃占用CPU资源
             	线程调用了一个阻塞时I/O方法,例如:获取键盘输入信息,那么在获取键盘输入信息方法返回前,此线程阻塞,
             	其它会引起阻塞的方法等等...       
             	
       DEAD  死亡状态
             当run()方法执行完毕,线程进入死亡状态.该线程等待,被GC回收(若此线程无引用)
			   注意:若线程进入DEAD状态后,不得调用start()方法,否则会引发异常
			   
===============================================================================
线程的状态管理
	1:让出CPU时间:yield()
	    当前线程让出CPU时间(主动从running状态回到runnable状态)
	2:休眠Thread.sleep(time)
	    当前线程进入阻塞状态,阻塞时间明确(参数给定,毫秒级).阻塞结束
	     后自动回到[runnable]状态.在睡眠阻塞过程中若打断这个线程的
	     阻塞状态会引发异常InterruptedException	
===============================================================================
线程常用的属性和方法
	线程优先级
		t.setPriority(int)
		默认有10个优先级,优先级高的线程获得执行(进入running状态)的机会多,但是注意,机会的多少不能通过代码干涉
		
		线程默认的优先级为5
		优先级常量:
			Thread.MAX_PRIORITY最高优先级10
			Thread.MIN_PRIORITY最低优先级1	     		   
			
		后台线程(守护线程,精灵线程)	
			t.setDaemon(true) 方法将线程设置为后台线程.黑夜情况下,线程的这个属性为false
			
			java进程结束:当前进程中所有[前台线程]都结束时,进程结束.也就是说,当所有前台线程
			             都结束后,无论后台线程是否还活着,都要被强制停止!
			设置后台线程的方法setDaemon(boolean)要在start()方法[执行前]被调用.
			
		获取线程名
			t.getName()
			
		获得当前线程
			Thread t = Thread.current();             
			          
===============================================================================
创建线程的两种方式
	继承Thread类，实现Runnable接口（线程体）              
	
	1:继承Thread类
		实现步骤:
			1 继承Thread类,重写run()方法(线程体,线程要执行的任务内容)
			2 创建该类的实例
			3 调用start()方法启动线程
			
	2:实现Runnable接口
		实现步骤:
			1 声明一个类并实现Runnable接口,重写run()方法
			2 创建该类的实例
			3 创建Thread类的实例
			  创建实例:Thread(Runnable runnable).在创建Thread
			  实例的同时,将Runnable的实例传入(给线程指派任务)
			4 调用start()方法启动线程
			
===============================================================================
Sleep阻塞打断唤醒

IO阻塞:通常IO操作都会发生阻塞

===============================================================================
异步和同步
	异步:并发的,各干各的
	同步:步调一致的,有先后顺序的
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             